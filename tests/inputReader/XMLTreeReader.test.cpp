//
// Created by frederik on 11/21/24.
//
#include "inputReader/XMLTreeReader.h"
#include "Environment.h"
#include "container/DSContainer.h"
#include "container/ParticleContainer.h"

#include <bits/fs_fwd.h>
#include <bits/fs_path.h>
#include <fstream>
#include <gtest/gtest.h>

// Tests if enum type a correct reflection of Environment.
TEST(XMLTreeReader, TestEnumTypeConversion) {
    // Boundary types
    EXPECT_EQ(INF_CONT, bound::INF_CONT) << "The enums INF_CONT and bound::INF_CONT must be interchangeable";
    EXPECT_EQ(HALO, bound::HALO) << "The enums HALO and bound::HALO must be interchangeable";
    EXPECT_EQ(HARD, bound::HARD) << "The enums HARD and bound::HARD must be interchangeable";
    EXPECT_EQ(PERIODIC, bound::PERIODIC) << "The enums PERIODIC and bound::PERIODIC must be interchangeable";
    EXPECT_EQ(OUTFLOW, bound::OUTFLOW) << "The enums OUTFLOW and bound::OUTFLOW must be interchangeable";
    // Writer types
    EXPECT_EQ(NO_OUT, output_t::format_type::NO_OUT) << "The enums NO_OUT and output_t::format_type::NO_OUT must be interchangeable";
    EXPECT_EQ(VTK, output_t::format_type::VTK) << "The enums VTK and output_t::format_type::VTK must be interchangeable";
    EXPECT_EQ(XYZ, output_t::format_type::XYZ) << "The enums XYZ and output_t::format_type::XYZ must be interchangeable";
    EXPECT_EQ(CHECKPOINT, output_t::format_type::CHECKPOINT) << "The enums CHECKPOINT and output_t::format_type::CHECKPOINT must be interchangeable";
    EXPECT_EQ(RDF, output_t::format_type::RDF) << "The enums RDF and output_t::format_type::RDF must be interchangeable";
    // Calculator types
    EXPECT_EQ(GRAVITY, param_t::calc_type::GRAVITY) << "The enums GRAVITY and param_t::calc_type::GRAVITY must be interchangeable";
    EXPECT_EQ(LJ_FULL, param_t::calc_type::LJ_FULL) << "The enums LJ_FULL and param_t::calc_type::LJ_FULL must be interchangeable";
    EXPECT_EQ(LJ_MOL, param_t::calc_type::LJ_MOL) << "The enums LJ_MOL and param_t::calc_type::LJ_MOL must be interchangeable";
    EXPECT_EQ(LJ_SMOOTH, param_t::calc_type::LJ_SMOOTH) << "The enums LJ_SMOOTH and param_t::calc_type::LJ_SMOOTH must be interchangeable";
    // Parallelization strategies
    EXPECT_EQ(SERIAL, param_t::strategy_type::SERIAL) << "The enums SERIAL and param_t::strategy_type::SERIAL must be interchangeable";
    EXPECT_EQ(GRID, param_t::strategy_type::GRID) << "The enums GRID and param_t::strategy_type::GRID must be interchangeable";
    EXPECT_EQ(SLICE, param_t::strategy_type::SLICE) << "The enums SLICE and param_t::strategy_type::SLICE must be interchangeable";
}

// We expect that code generated by a thrid party tool is generally correct and thus validates the XML files correctly.
// Tests if the reader validates at all
TEST(XMLTreeReader, TestXMLValidation) {
    // Empty XML with no schema
    EXPECT_EXIT(inputReader::XMLTreeReader reader("../tests/res/emptyXML.xml"), testing::ExitedWithCode(EXIT_FAILURE), "")
        << "The parser should catch empty XML files";
    // XML with missing values
    EXPECT_EXIT(inputReader::XMLTreeReader reader("../tests/res/TestValidationMissingValues.xml"), testing::ExitedWithCode(EXIT_FAILURE), "")
        << "The parser should catch missing values";
    // XML with misspelled element
    EXPECT_EXIT(inputReader::XMLTreeReader reader("../tests/res/TestValidationMisspelledElement.xml"), testing::ExitedWithCode(EXIT_FAILURE), "")
        << "The parser should catch missing elements";
}

// this tests if the non default values given in the xml file, are set correctly
TEST(XMLTreeReader, TestNonDefaultValues) {
    const char* xml = "../tests/res/testNonDefault.xml";

    Environment environment;
    Thermostat thermo;
    DSContainer container;
    physicsCalculator::Tweezers tweezer;
    inputReader::XMLTreeReader reader(xml);

    Thermostat exp_thermo;
    exp_thermo.set_active(true);
    exp_thermo.set_dimensions(2);
    exp_thermo.set_max_change(5);
    exp_thermo.set_T_target(28);

    ASSERT_NO_THROW(reader.readArguments(environment, thermo));
    ASSERT_NO_THROW(reader.readParticle(container, tweezer, environment.get_delta_t(), environment.get_gravity()));
    EXPECT_EQ(container.size(), 0);
    EXPECT_STREQ(environment.get_output_file_name(), "TestNonDefault");
    EXPECT_EQ(environment.get_output_file_format(), XYZ);
    EXPECT_EQ(environment.get_print_step(), 5);
    EXPECT_EQ(environment.get_calculator_type(), GRAVITY);
    std::array<BoundaryType, 6> boundaries = std::array<BoundaryType, 6> { PERIODIC, HARD, HALO, HARD, HALO, OUTFLOW };
    EXPECT_EQ(environment.get_boundary_type(), boundaries);
    EXPECT_EQ(environment.get_delta_t(), 0.5);
    EXPECT_EQ(environment.get_t_end(), 500);
    EXPECT_EQ(thermo, exp_thermo);
}

// test of the particles are inserted correctly
TEST(XMLTreeReader, TestParticles) {
    const char* xml = "../tests/res/testParticles.xml";

    DSContainer container;
    physicsCalculator::Tweezers tweezer;
    inputReader::XMLTreeReader reader(xml);
    Vec<double> x = { 0.1, 0.2, 0.3 };
    Vec<double> v = { 1.0, 1.5, 1.7 };
    double m = 0.01;

    reader.readParticle(container, tweezer, 0.0005, 0.0);

    ASSERT_EQ(container.size(), 1);
    EXPECT_EQ(container[0].getX(), x);
    EXPECT_EQ(container[0].getV(), v);
}

// test if the cuboid is generated correctly
TEST(XMLTreeReader, TestXMLCuboid) {

    const char* xml = "../tests/res/testCuboids.xml";

    DSContainer container;
    physicsCalculator::Tweezers tweezer;
    inputReader::XMLTreeReader reader(xml);

    Vec<double> x0 = { 0, 0, 0 };
    Vec<double> x1 = { 1, 0, 0 };
    Vec<double> x2 = { 0, 1, 0 };
    Vec<double> x3 = { 1, 1, 0 };
    Vec<double> v = { 0.5, 0.7, 0.9 };

    reader.readParticle(container, tweezer, 0.0005, 0.0);
    ASSERT_EQ(container.size(), 4);
    EXPECT_EQ(container[0].getX(), x0);
    EXPECT_EQ(container[1].getX(), x1);
    EXPECT_EQ(container[2].getX(), x2);
    EXPECT_EQ(container[3].getX(), x3);
    EXPECT_EQ(container[0].getV(), v);
    EXPECT_EQ(container[1].getV(), v);
    EXPECT_EQ(container[2].getV(), v);
    EXPECT_EQ(container[3].getV(), v);
}

// test if the disc is generated correctly
TEST(XMLTreeReader, TestXMLDisc) {
    const char* xml = "../tests/res/testDisc.xml";

    DSContainer container;
    physicsCalculator::Tweezers tweezer;
    inputReader::XMLTreeReader reader(xml);

    Vec<double> x1 = { -1, 0.0, 0.0 };
    Vec<double> x2 = { 0.0, -1, 0.0 };
    Vec<double> x3 = { 0.0, 0.0, 0.0 };
    Vec<double> x4 = { 0.0, 1, 0.0 };
    Vec<double> x5 = { 1, 0.0, 0.0 };
    Vec<double> v = { 1.0, 1.0, 1.0 };

    reader.readParticle(container, tweezer, 0.0005, 0.0);

    ASSERT_EQ(container.size(), 5);
    EXPECT_EQ(container[0].getX(), x3);
    EXPECT_EQ(container[1].getX(), x4);
    EXPECT_EQ(container[2].getX(), x2);
    EXPECT_EQ(container[3].getX(), x5);
    EXPECT_EQ(container[4].getX(), x1);
    EXPECT_EQ(container[0].getV(), v);
    EXPECT_EQ(container[1].getV(), v);
    EXPECT_EQ(container[2].getV(), v);
    EXPECT_EQ(container[3].getV(), v);
    EXPECT_EQ(container[4].getV(), v);
}

// Test if the membrane and tweezers are generated correctly
TEST(XMLTreeReader, TestXMLMembraneTweezer) {
    const char* xml = "../tests/res/testMembrane.xml";

    DSContainer container;
    physicsCalculator::Tweezers tweezer;
    inputReader::XMLTreeReader reader(xml);

    reader.readParticle(container, tweezer, 0.0005, 0.0);

    Vec<double> x1 = { 1, 2, 3 };
    Vec<double> x2 = { 2, 2, 3 };
    Vec<double> x3 = { 3, 2, 3 };
    Vec<double> x4 = { 1, 3, 3 };
    Vec<double> x5 = { 2, 3, 3 };
    Vec<double> x6 = { 3, 3, 3 };
    Vec<double> x7 = { 1, 4, 3 };
    Vec<double> x8 = { 2, 4, 3 };
    Vec<double> x9 = { 3, 4, 3 };
    Vec<double> v1 = { 3, 2, 1 };
    TypeDesc td { 2.0, 5.0, 6.0, 0.005, 0.0, 4.0, 2.0 };
    physicsCalculator::Tweezers tw;
    tw.set_end(15.0);
    tw.set_force({ -1.0, 0.0, 0.8 });
    tw.set_indices({ 0, 7, 2 });

    TypeDesc temp = container.get_type_descriptor(0);

    EXPECT_EQ(temp.get_mass(), td.get_mass()) << "Mass should be equal";
    EXPECT_EQ(temp.get_sigma(), td.get_sigma()) << "Sigma should be equal";
    EXPECT_EQ(temp.get_epsilon(), td.get_epsilon()) << "Epsilon should be equal";
    EXPECT_EQ(temp.get_G(), td.get_G()) << "F_grav should be equal";
    EXPECT_EQ(temp.get_k(), td.get_k()) << "Stiffness should be equal";
    EXPECT_EQ(temp.get_r0(), td.get_r0()) << "average bond length should be equal";

    EXPECT_EQ(tw, tweezer) << "Tweezers should be equal";
}

// test of everything combined has the correct value (with default value thermostat)

TEST(XMLTreeReader, TestXMLCombined) {
    const char* xml = "../tests/res/testCombined.xml";

    Vec<double> x1disc = { -1.5, 0.0, 0.0 };
    Vec<double> x2disc = { -0.5, -1, 0.0 };
    Vec<double> x3disc = { -0.5, 0.0, 0.0 };
    Vec<double> x4disc = { -0.5, 1, 0.0 };
    Vec<double> x5disc = { 0.5, 0.0, 0.0 };
    Vec<double> vdisc = { 0.5, 1.0, 1.0 };


    Vec<double> x0cuboid = { 0, 0, 0 };
    Vec<double> x1cuboid = { 1, 0, 0 };
    Vec<double> x2cuboid = { 0, 1, 0 };
    Vec<double> x3cuboid = { 1, 1, 0 };
    Vec<double> vcuboid = { 0.5, 0.7, 0.9 };

    Vec<double> xparticle = { 0.1, 0.2, 0.3 };
    Vec<double> vparticle = { 1.0, 1.5, 1.7 };

    Environment environment;
    Thermostat thermo;
    DSContainer container;
    physicsCalculator::Tweezers tweezer;
    inputReader::XMLTreeReader reader(xml);

    Thermostat exp_thermo;
    exp_thermo.set_active(true);
    exp_thermo.set_dimensions(3);
    exp_thermo.set_max_change(5);
    exp_thermo.set_T_target(40);

    reader.readArguments(environment, thermo);
    reader.readParticle(container, tweezer, environment.get_delta_t(), environment.get_gravity());

    ASSERT_EQ(container.size(), 10);

    EXPECT_EQ(container[0].getX(), xparticle);
    EXPECT_EQ(container[0].getV(), vparticle);

    EXPECT_EQ(container[1].getX(), x0cuboid);
    EXPECT_EQ(container[2].getX(), x1cuboid);
    EXPECT_EQ(container[3].getX(), x2cuboid);
    EXPECT_EQ(container[4].getX(), x3cuboid);

    EXPECT_EQ(container[5].getX(), x3disc);
    EXPECT_EQ(container[6].getX(), x4disc);
    EXPECT_EQ(container[7].getX(), x2disc);
    EXPECT_EQ(container[8].getX(), x5disc);
    EXPECT_EQ(container[9].getX(), x1disc);

    EXPECT_EQ(container[1].getV(), vcuboid);
    EXPECT_EQ(container[2].getV(), vcuboid);
    EXPECT_EQ(container[3].getV(), vcuboid);
    EXPECT_EQ(container[4].getV(), vcuboid);

    EXPECT_EQ(container[5].getV(), vdisc);
    EXPECT_EQ(container[6].getV(), vdisc);
    EXPECT_EQ(container[7].getV(), vdisc);
    EXPECT_EQ(container[8].getV(), vdisc);
    EXPECT_EQ(container[9].getV(), vdisc);

    EXPECT_EQ(thermo, exp_thermo);
}
